package com.hp.fm.service;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

import com.hp.fm.criteria.FmCriterion;
import com.hp.fm.db.DbException;
import com.hp.fm.db.dao.DaoHelper;
import com.hp.fm.db.dao.jpaimpl.AddressJpaDao;
import com.hp.fm.db.dao.jpaimpl.BuildingAddressJpaDao;
import com.hp.fm.db.dao.jpaimpl.BuildingJpaDao;
import com.hp.fm.db.dao.jpaimpl.BuildingLevelJpaDao;
import com.hp.fm.db.dao.jpaimpl.RegionJpaDao;
import com.hp.fm.db.dao.jpaimpl.SiteAddressJpaDao;
import com.hp.fm.db.dbenums.AddressTypeEnum;
import com.hp.fm.db.entity.Address;
import com.hp.fm.db.entity.Building;
import com.hp.fm.db.entity.BuildingAddress;
import com.hp.fm.db.entity.BuildingLevel;
import com.hp.fm.db.entity.Device;
import com.hp.fm.db.entity.Region;
import com.hp.fm.db.entity.SapAddress;
import com.hp.fm.db.entity.Site;
import com.hp.fm.db.entity.SiteAddress;
import com.hp.fm.db.entity.UserAccount;
import com.hp.fm.error_message.ErrorLocalEnum;
import com.hp.fm.error_message.ErrorMinorEnum;

public class AddressService extends ServiceBase implements IAddressService
{

    public void createAddress(Address address) throws ServiceException {
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        // set new value of a sequence to ship_to_code
        address.setShipToCode(DaoHelper
                .getSequenceShipToCode(getEntityManager()));

        try {
            addressDao.saveUpdateEntity(address);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    //added by Han
    public Region findRegionByRegionCountryId(String regionId, String countryId) 
    throws ServiceException
    {
        RegionJpaDao regionDao = new RegionJpaDao();
        regionDao.setEntityManager(getEntityManager());

        return regionDao.findRegionByRegionCountryId(regionId, countryId);
    }

    // added by Han
    public void createSiteAddress(SiteAddress siteAddress)
    throws ServiceException {
        SiteAddressJpaDao siteAddressDao = new SiteAddressJpaDao();
        siteAddressDao.setEntityManager(getEntityManager());

        try {
            siteAddressDao.saveUpdateEntity(siteAddress);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    // added by Han
    public void createBuildingAddress(BuildingAddress buildingAddress)
    throws ServiceException {
        BuildingAddressJpaDao buildingAddressDao = new BuildingAddressJpaDao();
        buildingAddressDao.setEntityManager(getEntityManager());

        try {
            buildingAddressDao.saveUpdateEntity(buildingAddress);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    public Address findAddressById(String id) throws ServiceException {
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());
        return addressDao.findById(id);
    }

    public void updateAddress(Address address) throws ServiceException {
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        // set new value of a sequence to ship_to_code
        address.setShipToCode(DaoHelper
                .getSequenceShipToCode(getEntityManager()));

        try {
            addressDao.saveUpdateEntity(address);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }

        // send notification email for ARC ship-to code created
        EmailService emailService = new EmailService();
        emailService.setEntityManager(getEntityManager());
        emailService.createNotificationEmailForArcShipToCodeCreated(address);
    }

    //added by Han
    public void updateSiteAddress(SiteAddress siteAddress) throws ServiceException {
        SiteAddressJpaDao siteAddressDao = new SiteAddressJpaDao();
        siteAddressDao.setEntityManager(getEntityManager());

        try {
            siteAddressDao.saveUpdateEntity(siteAddress);
        }
        catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    //added by Han
    public void updateBuildingAddress(BuildingAddress buildingAddress) throws ServiceException {
        BuildingAddressJpaDao buildingAddressDao = new BuildingAddressJpaDao();
        buildingAddressDao.setEntityManager(getEntityManager());

        try {
            buildingAddressDao.saveUpdateEntity(buildingAddress);
        }
        catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }


    public void deleteAddress(Address address) throws ServiceException {
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        try {
            addressDao.removeEntity(address);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    //added by Han
    public void deleteSiteAddress(SiteAddress siteAddress) throws ServiceException {
        SiteAddressJpaDao siteAddressDao = new SiteAddressJpaDao();
        siteAddressDao.setEntityManager(getEntityManager());

        try {
            siteAddressDao.removeEntity(siteAddress);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }

    //added by Han
    public void deleteBuildingAddress(BuildingAddress buildingAddress) throws ServiceException {
        BuildingAddressJpaDao buildingAddressDao = new BuildingAddressJpaDao();
        buildingAddressDao.setEntityManager(getEntityManager());

        try {
            buildingAddressDao.removeEntity(buildingAddress);
        } catch (DbException dbe) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, dbe);
        }
    }


    /**
     * searches building_address for maps with addresses and the specified site
     * - traverses the hierarchy tree if specified to do so
     * 
     * @param bldgId
     * @param addressType
     *            One of the AddressTypeEnum values. If null, the address type
     *            will not be used as one of the search criteria
     * @param cumulative
     *            if true, looks up to the parent site node if specified address
     *            is not found at the building node
     * @return list of addresses found, or empty list if none found
     */
    private Collection<Address> getAddressesForBuilding(String bldgId,
            AddressTypeEnum addressType, boolean cumulative)
            throws ServiceException {
        BuildingAddressJpaDao baDao = new BuildingAddressJpaDao();
        baDao.setEntityManager(getEntityManager());
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        LinkedList<Address> addresses = new LinkedList<Address>();
        Set<String> addressIDs = new HashSet<String>(); // we use a set, because
        // if the entry is
        // already there, the entry will not be added. This insures a list of
        // unique items

        Collection<BuildingAddress> baColl = baDao
        .findByBuildingAndAddressType(bldgId, addressType);

        if (baColl == null)
        {
            return addresses;
        }

        // now run through the returned list and create a list of (unique)
        // Address IDs
        for (BuildingAddress ba : baColl) {
            addressIDs.add(ba.getAddress().getAddressId());
        }

        // we have a list of unique address IDs found, turn them into a list of
        // addresses
        for (String addrId : addressIDs) {
            Address addr = addressDao.findById(addrId);
            if (addr != null)
            {
                addresses.add(addr);
            }
        }

        // by default, if the cumulative flag is true, it's the
        // getAddressesForBuilding signature
        // that specifies the addressType field - so we only do this if no
        // address was found because
        // once you find an address, you are done (always use the lowest level
        // found address)
        if (cumulative) {
            if (addressIDs.size() == 0) {
                // lookup parent site
                BuildingJpaDao buildingDao = new BuildingJpaDao(
                        getEntityManager());
                Building bldg = buildingDao.findById(bldgId);
                Site site = null;
                if (bldg != null)
                {
                    site = bldg.getSite();
                }
                if (site != null) {
                    Collection<Address> siteAddresses = getAddressesForSite(
                            site.getSiteId(), addressType);
                    for (Address addr : siteAddresses) {
                        addresses.add(addr);
                    }
                }
            }
        }

        return addresses;
    }

    public Collection<SiteAddress> getSiteAddressesBySite(Site site)
    throws ServiceException
    {
        SiteAddressJpaDao saDao = new SiteAddressJpaDao();
        saDao.setEntityManager(getEntityManager());
        return (saDao.findBySiteAndAddressType(site.getSiteId(), null));
    }


    public Collection<BuildingAddress> getBuildingAddressByBuilding(Building building)
    throws ServiceException
    {
        BuildingAddressJpaDao baDao = new BuildingAddressJpaDao();
        baDao.setEntityManager(getEntityManager());
        return (baDao.findBybuildingId(building.getBuildingId()));
    }


    public Collection<Address> getAddressesForBuilding(Building building)
    throws ServiceException {
        return getAddressesForBuilding(building.getBuildingId(), null, false);
    }

    public Collection<Address> getAddressesForBuilding(Building building,
            AddressTypeEnum addressType, boolean cumulative)
            throws ServiceException {
        if (addressType == null) {
            throw new ServiceException(ErrorLocalEnum.eInvalidParameter, ErrorMinorEnum.eServiceLayer,
            " addressType can not be null");
        }
        return getAddressesForBuilding(building.getBuildingId(), addressType,
                cumulative);
    }

    /**
     * searches site_address for maps with addresses and the specified site
     * 
     * @param siteId
     * @param addressType
     *            One of the AddressTypeEnum values. If null, the address type
     *            will not be used as one of the search criteria
     * @return list of addresses found, or empty list if none found
     */
    private Collection<Address> getAddressesForSite(String siteId,
            AddressTypeEnum addressType) throws ServiceException {
        SiteAddressJpaDao saDao = new SiteAddressJpaDao();
        saDao.setEntityManager(getEntityManager());
        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        LinkedList<Address> addresses = new LinkedList<Address>();
        Set<String> addressIDs = new HashSet<String>(); // we use a set, because
        // if the entry is
        // already there, the entry will not be added. This insures a list of
        // unique items

        Collection<SiteAddress> saColl = saDao.findBySiteAndAddressType(siteId,
                addressType);

        if (saColl == null)
        {
            return addresses;
        }

        // now run through the returned list and create a list of (unique)
        // Address IDs
        for (SiteAddress sa : saColl) {
            addressIDs.add(sa.getAddress().getAddressId());
        }

        // we have a list of unique address IDs found, turn them into a list of
        // addresses
        for (String addrId : addressIDs) {
            Address addr = addressDao.findById(addrId);
            if (addr != null)
            {
                addresses.add(addr);
            }
        }

        return addresses;
    }

    public Collection<Address> getAddressesForSite(Site site)
    throws ServiceException {
        return getAddressesForSite(site.getSiteId(), null);
    }

    public Collection<Address> getAddressesForSite(Site site,
            AddressTypeEnum addressType) throws ServiceException {
        if (addressType == null) {
            throw new ServiceException(ErrorLocalEnum.eInvalidParameter,ErrorMinorEnum.eServiceLayer,
            " addressType can not be null");
        }
        return getAddressesForSite(site.getSiteId(), addressType);
    }

    public Collection<Building> getBuildingForAddress(Address address)
    throws ServiceException {
        BuildingAddressJpaDao baDao = new BuildingAddressJpaDao();
        baDao.setEntityManager(getEntityManager());

        return baDao.findBuildingsByAddressId(address.getAddressId());
    }

    public Collection<Site> getSiteForAddress(Address address)
    throws ServiceException {
        SiteAddressJpaDao saDao = new SiteAddressJpaDao();
        saDao.setEntityManager(getEntityManager());

        return saDao.findSiteByAddressId(address.getAddressId());
    }

    public void removeAddressForBuilding(Building building,
            AddressTypeEnum addressType, Address address)
    throws ServiceException {
        BuildingAddress bAddr = null;
        BuildingAddressJpaDao baDao = new BuildingAddressJpaDao();
        baDao.setEntityManager(getEntityManager());

        // see if the address/type already exists
        Collection<BuildingAddress> bldgAddrs = baDao
        .findByBuildingAndAddressType(building.getBuildingId(),
                addressType);

        if (bldgAddrs.size() > 0) {
            // should never be more than one - if there is, ignore all but the
            // first
            bAddr = (BuildingAddress) (bldgAddrs.toArray()[0]);
            if (bAddr.getAddress() == address
                    && bAddr.getBuilding() == building
                    && bAddr.getPk().getAddressType() == addressType) {
                try {
                    baDao.removeEntity(bAddr);
                } catch (DbException e) {
                    throw new ServiceException(ErrorMinorEnum.eServiceLayer, e);
                }
            }
        } else {
            throw new ServiceException(ErrorLocalEnum.eNoRecordFound, ErrorMinorEnum.eServiceLayer,
            " matching BuildingAddress could not be found");
        }

    }

    public void removeAddressForSite(Site site, AddressTypeEnum addressType,
            Address address) throws ServiceException {
        SiteAddressJpaDao siteDao = new SiteAddressJpaDao();
        siteDao.setEntityManager(getEntityManager());

        // see if the address/type already exists
        Collection<SiteAddress> siteAddrs = siteDao.findBySiteAndAddressType(
                site.getSiteId(), addressType);

        SiteAddress sa = null;
        if (siteAddrs.size() > 0) {
            // should never be more than one - if there is, ignore all but the
            // first
            sa = (SiteAddress) (siteAddrs.toArray()[0]);
            if (sa.getAddress() == address && sa.getSite() == site
                    && sa.getPk().getAddressType() == addressType) {
                try {
                    siteDao.removeEntity(sa);
                } catch (DbException e) {
                    throw new ServiceException(ErrorMinorEnum.eServiceLayer, e);
                }
            }
        } else {
            throw new ServiceException(ErrorLocalEnum.eNoRecordFound, ErrorMinorEnum.eServiceLayer,
            " matching SiteAddress could not be found");
        }
    }

    // NOTE: Removed - it was decided to use searchAddressForSite and
    // searchAddressForBuilding instead
    // SQL WAS NOT FINISHED
    public Collection<Address> searchForAddressesByCriteria(FmCriterion criterion)
        throws ServiceException
    {
        FmCriterion crit = criterion == null ? new FmCriterion() : criterion;

        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        return addressDao.findAddressByCriteria(crit.getCompatibleQueryString(), crit.getParameters());
    }

    // return addresses that are associated with Site or Building
    public Collection<Address> searchForAddressesBySiteOrBuildingByCriteria(FmCriterion criterion, UserAccount user)
        throws ServiceException
    {
        FmCriterion crit = criterion == null ? new FmCriterion() : criterion;

        AddressJpaDao addressDao = new AddressJpaDao();
        addressDao.setEntityManager(getEntityManager());

        return addressDao.findAddressBySiteOrBuildingByCriteria(crit.getQueryString(), crit.getParameters(),
                user);
    }

    // added by Han
    public Collection<SiteAddress> searchForSiteAddressesByAllCriteria(FmCriterion criterion, UserAccount userAccount)
        throws ServiceException
    {
        FmCriterion crit = criterion == null ? new FmCriterion() : criterion;

        SiteAddressJpaDao siteAddressDao = new SiteAddressJpaDao();
        siteAddressDao.setEntityManager(getEntityManager());

        return siteAddressDao.findSiteAddressByCriteria(crit.getQueryString(), crit.getParameters(), userAccount);
    }

    // added by Han
    public Collection<BuildingAddress> searchForBuildingAddressesByAllCriteria(FmCriterion criterion,
            UserAccount userAccount)
        throws ServiceException
    {
        FmCriterion crit = criterion == null ? new FmCriterion() : criterion;

        BuildingAddressJpaDao buildingAddressDao = new BuildingAddressJpaDao();
        buildingAddressDao.setEntityManager(getEntityManager());

        return buildingAddressDao.findBuildingAddressByCriteria(crit.getQueryString(), crit.getParameters(),
                userAccount);
    }

    public Address searchHierarchyForAddressForDevice(Device device,
            AddressTypeEnum addressType) throws ServiceException {
        Collection<Address> addresses = null;
        BuildingLevelJpaDao levelDao = new BuildingLevelJpaDao(
                getEntityManager());

        if (device == null)
        {
            return null;
        }

        // get building ID by getting the devices level ID
        if (device.getBuildingLevel() != null) {
            BuildingLevel level = levelDao.findById(device.getBuildingLevel()
                    .getBuildingLevelId());
            if (level != null) {
                Building bldg = level.getBuilding();
                if (bldg != null) {
                    // search building address mappings (we'll do site below if
                    // nothing found, so
                    // we don't need to do the hierarchy. This is because the
                    // level is optional,
                    // but the site isn't
                    addresses = getAddressesForBuilding(bldg.getBuildingId(),
                            addressType, false);
                }
            }
        }

        // couldn't get from building, try site
        if (addresses == null || addresses.size() == 0) {
            if (device.getSite() != null) {
                addresses = getAddressesForSite(device.getSite().getSiteId(),
                        addressType);
            }
        }

        if (addresses == null || addresses.size() == 0)
        {
            return null;
        }

        // pick out the first one (really should only be one
        Address address = (Address) (addresses.toArray()[0]);

        return address;
    }

    public void setAddressForBuilding(Building building, Address address,
            AddressTypeEnum addressType) throws ServiceException {
        if (building == null || address == null) {
            throw new ServiceException(ErrorLocalEnum.eInvalidParameter, ErrorMinorEnum.eServiceLayer,
            " building and aaddressType can not be null");
        }

        BuildingAddressJpaDao baDao = new BuildingAddressJpaDao();
        baDao.setEntityManager(getEntityManager());

        try {
            baDao.setAddressForBuilding(building, address, addressType);
        } catch (DbException e) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, e);
        }
    }

    public void setAddressForSite(Site site, Address address,
            AddressTypeEnum addressType) throws ServiceException {
        if (site == null || address == null) {
            throw new ServiceException(ErrorLocalEnum.eInvalidParameter, ErrorMinorEnum.eServiceLayer,
            " site and aaddressType can not be null");
        }

        SiteAddressJpaDao siteDao = new SiteAddressJpaDao();
        siteDao.setEntityManager(getEntityManager());

        try {
            siteDao.setAddressForSite(site, address, addressType);
        } catch (DbException e) {
            throw new ServiceException(ErrorMinorEnum.eServiceLayer, e);
        }
    }

    public SapAddress getPhysicalAddressForDevice(Device device)
    throws ServiceException {
        // TODO Auto-generated method stub
        return null;
    }

    // NOTE: Removed - it was decided to use searchAddressForSite and
    // searchAddressForBuilding instead
    /*
     * public Collection<AddressDisplay>
     * searchForAddressDisplaysByCriteria(FmCriterion criterion) throws
     * ServiceException { AddressDisplayJpaDao addressDisplayDao = new
     * AddressDisplayJpaDao();
     * addressDisplayDao.setEntityManager(getEntityManager());
     * 
     * if (criterion == null) { criterion = new FmCriterion(); }
     * 
     * Map<String, Object> params = criterion.getParameters(); return
     * addressDisplayDao.search(criterion.getCompatibleQueryString(), params); }
     */
}
